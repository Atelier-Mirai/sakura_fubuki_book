= 初めてのJavaScript

//abstract{
  JavaScriptの文法を学びつつ、少しずつコードを追加していくことで、よりじゃんけんゲームらしく、作り上げていきます。
//}

前章では、HTMLの基本を学びました。
そして、JavaScriptは、HTML に組み込まれて使われることが多いプログラミング言語です。

先に書いたHTMLの一番最後に、次のような記述があったことを思い出してください。

//list[][JavaScriptの読み込み][63]{
  <!-- JavaScriptの読み込み -->
  <script src="janken.js"></script>
//}

これを書くことにより、 @<file>{janken.js} という JavaScriptのプログラムを読み込んで実行することができるようになります。

HTML, JavaScript と二つの言語が登場しました。後ほど CSS という言語も登場します。

 * HTML は、文書構造を記述します。
 * JavaScript は、ウェブサイトを制御します。
 * CSS は、ウェブサイトの飾り付けを担当します。

HTML, JavaScript, CSS と三つの言語が一緒になって、一つのウェブアプリが出来上がります。
@<file>{index.html}, @<file>{janken.js}, @<file>{janken.css} と三つのファイル、それぞれにコードを書いていきますので、少し大変かもしれませんが、進んでいきましょう。

== 初めての JavaScript
それでは、初めてのJavaScriptのプログラムを書き始めていきましょう。

@<file>{janken.js} というファイルを作り、次のように書きましょう。 @<fn>{1}
//footnote[1][「開発環境の準備」の章で、index.html を作りました。同様の手順で、janken.js というファイルを追加して、これを編集していきます。]

//list[][janken.js][file=source/janken00.js, 1]{
//}

//sideimage[win][55mm][sep=5mm, side=R]{
プログラムを書き終わったら保存しましょう。そしてブラウザを再読み込みします。すると、右のように「あなたの勝ちです!」とメッセージが表示されます。@<br>{}
　おめでとうございます。初めてのJavaScriptは、これで完成です!!
//}

=== 初めての JavaScript 解説

とても少ない行数のプログラムです。それぞれの行について解説していきます。

=== コメント
@<code>{//} と書かれた部分は、コメントです。 コードの説明書きに使います。 @<br>{}
処理の大まかな塊ごとに、コメントがついていると、プログラムの全体像が掴みやすく、作成者の意図も分かりやすくなります。一行ずつ全てにコメントを入れる必要はありませんが、要所要所で分かりやすくコメントをつけるように心がけましょう。 @<fn>{2}
//footnote[2][@<code>{/* コメント */} というコメントの書き方もあります。]

=== 厳格モード
JavaScriptには、歴史的な経緯により、陥りやすい意図しない動作が多々あります。

//list[][][1]{
// 厳格モードを呼び出すことで 潜在的なバグを減らす
'use strict';
//}

@<code>{'use strict';} と、プログラムの先頭に書くことで、 @<code>{厳格(strict)モード} になります。これにより、予期しない不具合を防ぐ効果があります。
詳しくは、(準)公式サイト MDN の @<href>{https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Strict_mode,厳格モード} をご覧になってください。

=== alert 関数

//list[][][4]{
// じゃんけんの勝ち負けの結果を表示する
alert("あなたの勝ちです!");
//}

JavaScriptには、よく使う処理に名前を付けて呼び出す働き・機能があります。
この働き・機能のことを「関数」と呼びます。(英語では、機能「function」です。)
メッセージ表示機能は便利ですので、JavaScriptには標準で@<code>{alert関数}が用意されています。 @<fn>{function}

//footnote[function][標準で備わっている関数を利用する他、プログラマが自分で好きな関数を作成できる機能もありますので、後述します。]

@<code>{alert関数}を使うには、@<code>{alert('表示させたいメッセージ');} と書くことで使えます。

JavaScriptを書くことで、勝利メッセージを表示できるようになりました。
すこしずつコードを追加していくことで、よりじゃんけんゲームらしくしていきましょう。
//blankline

それではどのようにすれば、より、じゃんけんゲームらしくなるでしょうか？ いきなり「あなたの勝ちです!」と表示されるのではなく、「プレイヤーが「開始」ボタンを押したら、結果が表示されるようにする」と、よりゲームらしくなりますね。

それでは、必要となるプログラミングに関する基礎知識を学んで行きましょう。

== 変数

プログラミング言語には、文字列や数値などのデータに名前をつけることで、繰り返し利用できるようにする変数という機能があります。「変数」とは「値」が格納できる「箱」のようなものであると想像すると理解しやすいでしょうか。

より正確な定義が、@<href>{https://e-words.jp/w/変数.html, IT用語辞典} にございますので、確認してみましょう。

//quote{
変数とは、コンピュータプログラムのソースコードなどで、データを一時的に記憶しておくための領域に固有の名前を付けたもの。変数につけた名前を変数名と呼び、記憶されているデータをその変数の値という。データの入れ物のような存在で、プログラム中で複数のデータを扱いたいときや、同じデータを何度も参照したり計算によって変化させたい場合に利用する。
//blankline
変数をプログラム中で利用するには、これからどんな変数を利用するかを宣言し、値を代入する必要がある。コード中で明示的に宣言しなくても変数を利用できる言語もある。変数に格納された値を利用したいときは、変数名を記述することにより値を参照することができる。
//}

定義ですので、少し難しいかもしれませんが、何度も出てきますので、すぐに使いこなせるようになる事と思います。

//note[変「数」の名前の由来]{
英語では、@<code>{variable} と言います。「変わりうるもの」という意味です。

例えばプログラムの中で、年齢を扱っているような場合を考えて見ましょう。10歳だった人は五年経てば15歳に、10年経てば20歳にと、年月の経過とともに変化して行きます。

あるいは、身長や体重の例はどうでしょうか。50.0kgの人は翌日になれば50.1kgになっているかもしれませんし、さらに次の日には49.8kgになっているかもしれません。

10   ⇒ 15   ⇒ 20

50.0 ⇒ 50.1 ⇒ 49.8

以上は「数値」が「変わりうるもの」という例でした。

//blankline
他の例として「名前」はどうでしょうか。生まれたばかりの赤ちゃんにはまだ名前がありませんが「お七夜」の祝宴で「太郎」と命名され、家族に迎え入れられます。あるいは婚姻により「田中」さんが「山田」さんに名前が変わることもあります。

名無し ⇒ 太郎

田中   ⇒ 山田

以上は「文字列」が「変わりうるもの」という例でした。

@<code>{variable} を、変「数」という日本語に訳されましたが、「数」だけではなく「文字列」やそのほかいろいろ「変わりうるもの」全般を表すプログラミング用語であることを、心に留めておいてください。
//}

では、これから学ぶ JavaScript ではどのように「変数」を使えば良いのでしょうか。JavaScript では、どのような名前の変数を自分が書くプログラムで使うのか、最初に「宣言」する必要があります。変数宣言をする為のキーワードとして @<code>{const, let, var} の3つが用意されていますので、順に見て行きましょう。

//tip{
 * @<code>{let}   は、「変数」を宣言する時に使います。何度でも値の変更が可能です。
//}

それでは、使って見ましょう。

//list[][変数宣言の例]{
// コンピュータの手として、computer という変数を宣言する
let computer;
//}

変数の宣言をすると、その変数に値を入れる（代入する）ことができます。

//list[][変数に値を入れる例]{
// コンピュータの手として、computer という変数を宣言する
let computer;

// computer という変数に値を入れる
computer = 0;
//}

変数の宣言と同時にその変数に値を入れる（代入する）こともできます。

//list[][変数宣言と、変数への値の代入を同時に行う例]{
// コンピュータの手として、
// computer という変数を宣言するとともに、
// computer という変数に値を入れる
let computer = 0;
//}

変数には値を何度でも代入することができます。
次の例は、0, 1, 2 と変化させた例です。

//list[][変数への値の代入を何度も行った例]{
computer = 0;
computer = 1;
computer = 2;
//}

また、変数名の宣言は一度だけで十分です。同じ変数名で何度も宣言する必要はありませんし、また出来ませんので、ご注意下さい。

次の例はエラー（誤り）となります。

//list[][変数宣言を何度も行った例]{
let computer;
let computer = 0;
computer = 1;
let computer = 2;
//}

//note[=(イコール)記号について]{
@<code>{=(イコール)}は、数学ですと、@<B>{computerと1が「等しい」}ということを意味する記号ですが、プログラミングの世界では @<B>{左の変数に右の値を入れる（代入する）} という記法になります。

初期には「等しい」ことを示す @<code>{=}と区別するために別の記号が用いられた時代もありましたが、@<ruby>{C言語,シーげんご}や@<ruby>{Ruby,ルビー}, @<ruby>{JavaScript,ジャバスクリプト}など現在主流の多くの言語では「代入する」記号として@<code>{=}を用いています。@<small>{（「等しい」意味では == や === を用います。）}

始めのうちは @<B>{@<code>{computer ⇦ 1;}} のことだと、頭の中で置き換えると良いでしょう。
//}

== 定数
それでは、次に「定数」を見て行きましょう。
@<href>{https://e-words.jp/w/定数.html,IT用語辞典} には、次のように書かれています。

//quote{
定数とは、コンピュータプログラムのソースコードなどで、ある特定の数値やデータに名前を与えたもの。変数とは異なり、宣言時に決めた値をコードの中で後から変更することができない。

プログラムのコード中で何度も参照される値で、実行時に変更する必要のないものに用いられる。値（数値や文字列）が開発の途中で変更される可能性がある場合や、値が長くて何度も入力すると打ち間違える危険がある場合、値に分かりやすい名前をつけたい場合などに用いられる。
//}

「定数」@<fn>{3} を宣言する為には、@<code>{const} というキーワードを使います。英語の @<code>{constant(一定の、不変の)}に由来しています。定数は一度決めた値を変更することは出来ません。@<small>{（しようとするとエラーになります。）}

//footnote[3][厳密には「再代入できない変数」の宣言です。]

//tip{
 * @<code>{const}   は、「定数」を宣言する時に使います。初回のみ値を設定できます。
//}

それでは、早速、使って見ましょう。先の変数の例では、@<code>{computer = 0;}などと書いていました。@<code>{computer}という変数に@<code>{0}を代入するという意味ですが、この@<code>{0}という数値は一体どういう意味なのか、覚えておくのも大変です。そこで分かりやすい名前を付けたいと思います。

//list[][定数宣言の例]{
// 定数宣言
const GUU   = 0; // グー
const CHOKI = 1; // チョキ
const PAA   = 2; // パー
//}

@<code>{const GUU} と 定数を宣言すると同時に @<code>{= 0;} で値を設定しています。

こうして定数を宣言しましたので、プログラム中では次のように使うことが出来ます。

//list[][定数を利用した例]{
// 定数宣言
const GUU   = 0; // グー
const CHOKI = 1; // チョキ
const PAA   = 2; // パー

// コンピュータの手
let computer = GUU;
//}

@<code>{let computer = GUU;}と、プログラムを書くことが出来るようになりました。@<code>{let computer = 0;} と書くよりも文字数は増えていますが、@<code>{0}, @<code>{1}, @<code>{2} の単なる数字とは異なり、その意味するところが明確で、とても分かりやすくなりました。活用してきましょう。


== 使用しない変数宣言のキーワード @<code>{var}

JavaScript には、@<code>{let, const} の他に、もう一つ@<code>{var}という変数宣言の為のキーワードもあります。

@<code>{var} は、以前は使われていましたが、数々の不具合があるので、それに代わる変数宣言の為のキーワードとして @<code>{let, const} が導入されました。

今でも、古いプログラムコードには使われていますが、これから書くときには、@<code>{let} または @<code>{const} を用いるようにしましょう。

//tip{
 * @<code>{var} は、以前は使われていましたが、数々の不具合があるので、今日では使用しません。
//}

== 命名規則

@<code>{computer} という名前の変数や、@<code>{GUU} という名前の定数を宣言しましたが、変数や定数にはどのような名前を付けられるのでしょうか。

変数名には アルファベット(と一部の記号) @<code>{a-z, A-Z, $, _(アンダースコア)} が使えます。これらのアルファベット(と一部の記号)の後ろに @<code>{0-9} までの数字を続けることも出来ます。
また、JavaScript 自身が使う為の単語（予約語と言います）そのものは、変数名や定数名として宣言することは出来ませんが、予約語の一部を含むものは使うことができます。

//tip{
@<B>{使える例}

 * @<code>{let a;                 // 一文字の変数名も使えます}
 * @<code>{let computer;          // 英単語も使えます}
 * @<code>{let conputer;          // つづりが間違っていても使えます}
 * @<code>{let player1;           // 英単語の後ろに数字を繋げても良いです}
 * @<code>{let player9876;        // 沢山の数字を繋げることも出来ます}
 * @<code>{let player9876;        // 沢山の数字を繋げることも出来ます}
 * @<code>{let playerName;        // 英単語を繋げるときには(慣習的に)先頭を大文字にします}
 * @<code>{let player_name;       // _ で繋げても良いですが、JavaScriptでは一般的ではありません}
 * @<code>{const GUU;             // 定数を宣言する時には(慣習的に)全て大文字にします}
 * @<code>{const GUU_CHOKI_PAA;   // いくつかの単語を繋げるときは _ で繋ぎます}@<br>{}


 * @<code>{let knife;             // if は予約語なので使えませんが、ifを含む単語は使えます}
//}

//tip{
@<B>{使えない例}

 * @<code>{let 123;               // 数字そのものを変数名にすることは出来ません}
 * @<code>{let 20th_century_pear; // 数字から始まる変数名を使うことも出来ません}
 * @<code>{let twentieth-century; // -(ハイフン)は使えない記号です}
 * @<code>{let var;               // var は、予約語そのものなので使えません}
 * @<code>{let variable;          // variable は、予約語を含んでいますがなので使えません}@<br>{}

 * @<code>{let if;                // if は予約語なので使えません。}
//}




== 関数
関数とは、ある一連の手続き（文の集まり）を一つの処理としてまとめる機能です。関数を利用することで、同じ処理を毎回書くのではなく、一度定義した関数を呼び出すことで同じ処理を実行できます。
@<fn>{function2}
//footnote[function2][例えば、勝ち負けの判定を纏めておくと、使い勝手が良さそうです。]

JavaScriptでは、関数を定義するために @<code>{function} キーワードを使います。 @<code>{function} から始まる文は関数宣言と呼び、次のように関数を定義できます。

//list[][関数宣言]{
// 関数宣言
function 関数名(仮引数1, 仮引数2) {
    // 関数が呼び出されたときの処理
    // ...
    return 関数の返り値;
}

// 関数呼び出し
const 関数の結果 = 関数名(引数1, 引数2);
alert(関数の結果); // => 関数の返り値を表示する
//}

関数は次の4つの要素で構成されています。

//tip{
@<B>{関数を構成する4つの要素}@<br>{}

 : 関数名
    利用できる名前は変数名と同じ
 : 仮引数
    関数呼出時に渡された値が入る変数で、複数の場合は,(カンマ)で区切る
 : 関数の中身
    「{」と「}」で囲んだ関数の処理を書く場所
 : 関数の返り値
    関数を呼び出したときに、呼び出し元へ返される値
//}

宣言した関数は、@<code>{関数名()}と関数名に括弧を付けて呼び出します。
関数を@<ruby>{引数,ひきすう}と共に呼ぶ際は @<code>{関数名(引数)} とし、引数が複数ある場合は  @<code>{関数名(引数1, 引数2)}のように、@<code>{,（カンマ）} で区切ります。
関数内では @<code>{return文} により、関数の実行結果として任意の値を返せます。 @<fn>{61}
//footnote[61][出典：JavaScript Primer 迷わないための入門書]

//blankline

それでは、理解を深めるために、例を挙げてみましょう。
とても単純ですが、a と b という二つの数を足し算する関数です。
足し算(@<code>{add})用に、@<file>{add.html} という HTMLファイルと @<file>{add.js}
という JavaScriptファイルを作ります。

@<file>{add.html} は、@<file>{add.js} を呼び出すだけの HTML ファイルです。
//list[][add.html][file=source/add.html, 1]{
//}

@<file>{add.js} は、二つの数 の足し算を行い、結果を表示するためのプログラムです。
//list[][add.js][file=source/add.js, 1]{
//}

//sideimage[add][60mm][sep=5mm,side=R]{
@<code>{32}という結果が画面に表示されました。とても簡単な例でしたが、
関数の作り方、使い方は理解できましたでしょうか。 @<fn>{nissuu}

それでは、次の話題へと進んでいきましょう。
//}
//footnote[nissuu][物足りなかった方は、九月二十三日は元旦から数えて何日目か？ を計算して表示するプログラムを作ってみましょう。一例は章末をご覧ください。]

//clearpage

===[column] 新しい関数の書き方 アロー関数のご紹介

==== @<ruby>{ECMAScript,エクマ スクリプト}
JavaScriptは、@<ruby>{Ecma International,エクマ インターナショナル}（旧欧州電子計算機工業会 European Computer Manufacturers Association）によって仕様が定められています。第一版から始まり、第五版の @<ruby>{ECMAScript,エクマ スクリプト} 5th edition(ES5)まで順調に機能向上が図られてきましたが、全ての仕様を策定し第○版として取りまとめる都合上、公開に時間を要するという課題がありました。@<br>{}

そのため、より迅速に公開できるよう、それぞれの仕様について合意が得られた部分から順次公開して行くように方針の転換が図られました。この方針転換を受けて最初に公開されたのが「ECMAScript 2015(ES2015)」です@<small>{(グレゴリオ暦に因んだ命名で、第二千十五版ではありません)}。それ以降、毎年様々な仕様の追加が行われ、ES2016, ES2017, ES2018... と呼ばれています。

==== ES2015
ES2015は、従来のJavaScript(ES5)を、より近代的なプログラミング言語に生まれ変わらせるべく、大きな仕様の変更が行われました。

 * アロー関数
 * クラス構文
 * テンプレート文字列
 * 分割代入
 * デフォルト引数
 * 新しい変数宣言(@<code>{let}, @<code>{const})
 * 新しい繰り返し構文(@<code>{for of})
 * モジュール(@<code>{import}, @<code>{export})
 * 各種ライブラリの追加
 * などなど

==== アロー関数
ここでは、新しい関数の書き方「@<B>{アロー関数}」について、ご紹介いたします。
（アロー関数は、関数を表す為の記号 @<code>{ => } が、「矢印、@<ruby>{arrow,アロー}」に見えるので、そう呼ばれます。）

二つの数 @<code>{a} と @<code>{b} を与えると、その和を返す関数@<code>{add}を定義してみましょう。

新しく導入されたアロー関数を使う場合は、次のように書きます。

//list[][新しく導入されたアロー関数]{
// アロー関数
const add = (a, b) => {
  return a + b;
}
//}

従来の関数宣言では次のようになります。
//list[][従来の関数宣言]{
// 従来の関数宣言
function add(a, b) {
  return a + b;
}
//}

使い方はどちらも同じで、次のようにして結果を表示できます。

//list[][関数の呼び出し]{
// 関数の呼び出しと結果の表示
const answer = add(9, 23);
alert(answer);
//}

==== 従来型の関数と「アロー関数」への変形
「変数」とは「値」が格納できる「箱」のようなものです。ですので「9」や「23」といった数値、「September」などの文字列を代入（格納）できるのは、理解しやすいでしょう。

そして、JavaScriptの関数は「第一級オブジェクト」と呼ばれ、関数を変数に代入できる！性質を持ちます。9と23を足し算した結果である32を変数に代入するのではなく、「足し算する」という「機能・働き・関数」そのものを変数に代入できるという、特筆すべき性質を持っています。

ですので、次のように 変数 @<code>{add} に 関数 @<code>{tashizan}を代入することができます。
//list[][]{
// 変数 add に 関数tashizanを代入する
const add = function tashizan(a, b) {
  return a + b;
}
//}

そして使うときには、あたかも変数@<code>{add}が関数であるかのように（関数を代入しているのですから全く関数と同じように）利用できます。

//list[][]{
// 関数の呼び出しと結果の表示
const answer = add(9, 23);
alert(answer);
//}

変数 @<code>{add} に代入して、「足し算をする」という機能を呼び出せるのであれば、わざわざ 関数に @<code>{tashizan} と命名する必要も無いので、名前を省けます（「無名関数」と言います）。

//list[][]{
// 変数 add に 無名関数を代入する
const add = function (a, b) {
  return a + b;
}
//}

@<code>{function} と毎回書くのも文字が長いので省略して、代わりに アロー関数の記法 @<code>{ => } を @<code>{ () } の次に書きます。

//list[][アロー関数の完成]{
const add = (a, b) => {
  return a + b;
}
//}

このテキストでは、@<code>{function} というキーワードの存在が、始めての方に分かりやすいかと考え、従来型の関数宣言でコーディングしています。

「アロー関数」は、従来型の関数宣言と全く同一のものではありませんが、簡潔に書けるよう、これからの主流として導入され、広く用いられていますので、ぜひ使ってみてください。

//blankline
またより詳しい説明が、（準）公式サイト ＭＤＮ @<href>{https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Functions/Arrow_functions,アロー関数式} にございますので、ご興味を持った方はお読みになってください。

===[/column]

== JavaScript から HTMLを操作する為の仕組み - DOM

わたくしたちが実現したい事は「開始ボタンを押すとメッセージを表示する」ことです。
ここまでで、変数や定数、関数といったプログラミングの基本的な部品について紹介しました。
そしてあと二つ学ぶべき事柄が残っています。一つは「DOM」でもう一つは「イベント」です。まず「DOM」についてご紹介いたします。

DOMとは何でしょうか。
@<href>{https://e-words.jp/w/DOM.html,IT用語辞典} の説明を見て見ましょう。
//quote{
DOMとは、HTML文書を構成する要素をコンピュータプログラムで参照したり操作したりするための取り決め。

HTMLで記述されたウェブページなどの構成要素（見出し、段落、画像、リンクなど）と、それらの配置や見栄えなどを定めた属性情報などを参照、制御する手法を定めている。ウェブブラウザなどに実装されており、ページ上にJavaScriptなどで記述されたスクリプトからページ内の各要素を読み取ったり、内容や設定の変更、要素の追加や削除などを行う標準的な手段として用いられる。
//}

辞典ですので、きっちりと書かれておりますが、少し難しく感じるかもしれません。

（準）公式サイトＭＤＮにも @<href>{https://developer.mozilla.org/ja/docs/Web/API/Document_Object_Model/Introduction,DOMの紹介} がございますので、その一部を抜粋しましょう。

//quote{
ドキュメントオブジェクトモデル (DOM) はウェブ文書のためのプログラミングインターフェイスです。ページを表現するため、プログラムが文書構造、スタイル、内容を変更することができます。 DOM は プログラミング言語をページに接続することができます。
//}

分かりやすくなったでしょうか。

//tip{
  @<B>{ドキュメントオブジェクトモデル (DOM)} とは、@<B>{HTMLで作られたウェブページと、プログラミング言語であるJavaScriptを繋ぐ為の仕組み} で、DOMを仲立ちにすることで、JavaScript から HTMLを操作できる。
//}

それでは、練習用の簡単なHTMLを準備して、実験して見ましょう。ファイル名は @<file>{dom.html}としましょう。

//list[][dom.html][file=source/dom0.html, 1]{
//}

作成した @<file>{dom.html} を、ブラウザで開いて見ましょう。小さな「開始」ボタンが表示されているはずです。

次に、もう一つファイルを作成し、ファイル名は @<file>{dom.js}とします。
そして、次のようなJavaScriptのプログラムを書きましょう。
//list[][dom.js][file=source/dom.js, 1]{
//}

この JavaScript を HTML から読み込む為に、最初に書いた @<file>{dom.html} の終わりに @<code>{<script src="dom.js"></script>} の一行を追加します。

//list[][dom.html][file=source/dom.html, 1]{
//}

これで準備は完了です。

もう一度、作成した @<file>{dom.html} を、ブラウザで開いて見ましょう。
先ほど表示されていた小さな「開始」ボタンに代わり、「もう一度」と表示されているはずです。

JavaScript から HTMLを操作することが出来ました。


== イベントリスナと関数

=== イベントリスナ
#@# 先程のプログラムでは、利用者(ユーザ)が何もすることなく、勝利メッセージが表示されました。これではゲームらしくありません。

それでは次に利用者（ブラウザを閲覧、操作する人）が、「何か操作を行った時」に、「メッセージを表示する」ようにしましょう。

JavaScriptには、@<B>{イベントリスナ} と呼ばれる仕組みが有り、「何か操作を行った時」に指定した動作をする機能が備わっています。

それでは、@<B>{イベント}、@<B>{リスナー} とはなんでしょうか。それぞれの用語の意味を調べてみましょう。
//quote{
//noindent
プログラミングにおけるイベント (英: event) は、プログラム内で発生した動作・出来事、またそれらを表現する信号である。 メッセージあるいはアクション（動作）とも呼ばれる。
イベントの例としてウェブブラウザにおける「ページが読み込まれた時」、「クリック動作」、「スクロール操作」などさまざまなイベントがある。 @<fn>{fn-51}
//}
//footnote[fn-51][出典：Wikipedia]

//quote{
//noindent
リスナーとは、聞く人、聞き手、聴取者、聴講生、などの意味を持つ英単語。一般の外来語としてはラジオ（局/番組）の聴取者を意味する用法が有名である。

プログラミングの分野では、何らかのきっかけに応じて起動されるよう設定されたサブルーチンや関数、メソッドなどをイベントリスナー（event listener）あるいは単にリスナーという。例えば、「マウスがクリックされると起動するよう指定された関数」のことを「マウスクリックを待ち受けるリスナー」といったように呼ぶ。 @<fn>{fn-52}
//}
//footnote[fn-52][出典：IT用語辞典]

つまり、@<B>{イベントリスナー}とは次のようになります。

//quote{
//noindent
「ページ読み込みやクリック動作など、ウェブページで行われる様々な動作を常時起動し待ち受けて(聴取し続けて)、イベントが起きた時に指定された処理を行う関数のこと」@<fn>{fn-53}
//}
//footnote[fn-53][参考：フロントエンドエンジニアを目指す! JavaScript講座(9)イベントリスナーを使用する]

この、@<B>{イベントリスナー} の仕組みを利用して、「利用者」が「グー」を出したときに、勝ち負けを判定するなど、じゃんけんゲームを作り上げていきます。

== 開始ボタンを押すと応答するプログラム
ここまでで、お膳立てができましたので、以下のように書きましょう。

//list[][janken.js][file=source/janken10.js, 1]{
//}

一行ずつ解説していきます。

6行目の @<code>{const playButton = document.getElementById("play");} についてです。まず @<code>{document.getElementById("play");} で、HTML に書いた 開始ボタン要素を取得します（DOM という仕組みにより、JavaScript から HTML要素を操作できました）。そして取得した 開始ボタン要素をプログラムの中で扱いやすくするために @<code>{playButton} という変数を宣言し、代入しています。

11行目の @<code>{playButton.addEventListener("click", jankenHandler);} です。
まず @<code>{playButton} にイベントリスナを追加します(@<code>{addEventListener})。
画面が読み込まれた時、スクロールされた時など、さまざまなイベントがありますが、ここでは、クリック(@<code>{click})された時に、 @<code>{jankenHandler} という関数が呼ばれるようにします。 @<fn>{71}
//footnote[71][@<code>{jankenHandler} という関数が、クリックして欲しいと耳を澄ましてラジオを聴取しているイメージを持つと理解しやすいでしょう。]

15行目から17行目は、@<code>{jankenHandler} という関数を定義しています。
@<code>{jankenHandler} は、Handle（車のハンドル、操舵輪、取扱者）の意味です。じゃんけんに関する事柄を取り扱うので、分かりやすいように @<code>{jankenHandler} と関数名を付けています。 関数名は任意ですが、分かりやすい名前にすることで、良いプログラムを書くことができます。

@<code>{playButton}にイベントリスナを追加したので、@<code>{playButton} がクリックされると、@<code>{jankenHandler}関数が呼び出されて実行されるようになります。

それでは、 @<code>{janken.js} を保存して、ブラウザを再読み込みしてみましょう。
「開始」ボタンを押すと、「あなたの勝ちです!」とメッセージが出るようになりました。

== 繰り返し処理
それでは、三回勝利メッセージを表示したいときはどのようにすれば良いでしょうか？

//list[][]{
// じゃんけんの勝ち負けの結果を表示する関数
function jankenHandler(event) {
  alert("あなたの勝ちです!");
  alert("あなたの勝ちです!");
  alert("あなたの勝ちです!");
}
//}
このように三回書いたらできます。それでは百回表示させたいときはどうでしょうか。エディタのコピー機能を使うこともできますが、それでも百回書くのは大変です。

プログラミング言語には、同じ処理を繰り返したいときの為の専用の構文(書き方)が用意されています。さまざまな書き方が可能ですが、ここでは基本の @<code>{for文} を使い、次のように書いてみましょう。

//list[][]{
// じゃんけんの勝ち負けの結果を表示する関数
function jankenHandler(event) {
  for(let i = 0; i < 3; i++) {
    alert("あなたの勝ちです!");
  }
}
//}

三回、勝利メッセージが表示されました。上のプログラム中、 @<code>{3} と書かれているところを、@<code>{100} と書き換えると、百回表示させることもできます。 @<fn>{loop}

//footnote[loop][@<href>{https://ja.wikipedia.org/wiki/アラートループ事件, アラートループ事件} 兵庫県警によりウイルス罪として女子中学生ら五人が捕えられた誤認・冤罪事件。JavaScriptの生みの親であるブレンダン・アイクは「Chromeの初版よりも10年も前にリリースされたNetscape 4でもユーザーがループするJavaScriptをキルすることができた。」「この事件の公判で専門家証人になるつもりでいる。これはウイルスなどではなく、犯罪扱いされるべきではない。」とツイートした。]

for文は繰り返す範囲を指定した反復処理を書くことができます。
たびたび登場している名著「JavaScript Primer 迷わないための入門書」から、for文の説明を見てみましょう。

//list[][for文]{
for (初期化式; 条件式; 増分式) {
    実行する文;
}
//}

for文の実行フローは次のようになります。

 1. 初期化式 で変数の宣言
 2. 条件式 の評価結果がtrueなら次のステップへ、falseなら終了
 3. 実行する文 を実行
 4. 増分式 で変数を更新
 5. ステップ2へ戻る

次のコードは、@<code>{for文} で 1から10までの値を合計して、その結果を出力するプログラムです。 @<fn>{total} 今まで作って来た、 @<file>{janken.js} の最後に追加してみましょう。
//footnote[total][アルゴリズムやプログラミングの章で登場してきた話題です。]

//list[][1から10までの合計を求めるプログラム]{
// totalの初期値は0
let total = 0;

// for文の実行の流れ
// まず、iを1で初期化
// iが10以下（条件式を満たす）ならfor文の処理を実行
// iに1を足し(i++)、再び条件式の判定へ
for (let i = 1; i <= 10; i++) {
  // 1から10の値をtotalに加算している
  total = total + i;
}

// コンソールに55が出力される
console.log(total);
//}

「@<B>{コンソール}」という新しい言葉が登場しました。「操作盤」という意味をもつ英単語で、
@<code>{console.log()} という命令(メソッド、関数)を使って、ブラウザのコンソール画面という開発者用の画面に結果を表示できます。

Firefoxでは、次のようにすると、開発者ツールのウェブコンソールと呼ばれる画面を表示できます。

 1. ブラウザ画面を右クリック
 2. 「調査」をクリック
 3. 「コンソール」パネルをクリック

 コンソール画面に @<code>{55} と出力されているはずです。

//image[web-console2][][width=50%]

== 条件分岐
じゃんけんは、勝つこともあれば、負けることもあります。
条件分岐を使うと、特定の条件を満たすかどうかで行う処理を変更できます。

この章では @<code>{@<ruby>{if,イフ}文} を使った条件分岐について学んでいきます。

@<code>{if文} は次のような構文が基本形となります。
条件式の評価結果が @<code>{@<ruby>{true,トゥルー}} (@<ruby>{真,しん}・成り立つ)であるならば、実行する文が実行されます。

（反対語は @<code>{@<ruby>{false,フォールス}} (@<ruby>{偽,ぎ}・成り立たない)で、後ほど登場します。）

//list[][if文]{
if (条件式) {
  実行する文;
}
//}

@<B>{もし、条件式が真(成り立つ)ならば、波括弧{ \}内に書かれた文を実行する } という意味です。

例として、映画館の料金を表示するプログラムを考えてみましょう。

次のコードでは条件式が @<code>{true} (真・成り立つ)であるため、 @<code>{if文} の中身が実行され、コンソール画面に「大人料金です」と表示されます。

//list[][if文の条件式がtrue]{
// 年齢は20歳
const age = 20;

if (age >= 18) {
  console.log("大人料金です");
}
//}

複数の条件分岐を書く場合は、 @<code>{if文} に続けて @<code>{@<ruby>{else,エルス} if文} を使うことで書けます。 たとえば、次のように3つに条件分岐するプログラムを書けます。

//list[][else if文]{
// 年齢は10歳
const age = 10;

if (age >= 18) {
  console.log("大人料金です");
} else if (age >= 12) {
  console.log("中高生料金です");
} else if (age >= 6) {
  console.log("小学生料金です");
}
//}

@<code>{if文} と @<code>{else if文} では、条件に一致した場合の処理をブロック内に書いていました。 一方で条件に一致しなかった場合の処理は、 @<code>{else文} を使うことで書けます。

//list[][else if文]{
// 年齢は5歳
const age = 5;

if (age >= 18) {
  console.log("大人料金です");
} else if (age >= 12) {
  console.log("中高生料金です");
} else if (age >= 6) {
  console.log("小学生料金です");
} else {
  console.log("無料です");
}
//}

小学生未満無料とは、気前のよい映画館ですね。

//blankline

それでは本題のじゃんけん機能を充実させていきましょう。勝負のドキドキが味わえるようにしていきます。
そのために、@<code>{if文} を使って、以下のように書いてみましょう。

//list[][janken.js][file=source/janken30.js, 1]{
//}

7行目までは、前回と一緒です。10行目と11行目で、プレイヤーが入力した手を取得しています。
@<file>{index.html}内で書いた @<code>{<input type="number" id="player_hand_type" value="0">} 要素を JavaScript から扱っていきます。

そのために @<file>{janken.js}内で @<code>{document.getElementById("player_hand_type");}と書き、このプレイヤーの入力枠をJavaScriptで取得します。取得した入力枠に名前があると扱いやすいので、@<code>{const inputBox} と書き @<code>{inputBox}という名前の変数を用意します。そして @<code>{const inputBox = document.getElementById("player_hand_type"); } と @<code>{代入演算子 @<ruby>{=,イコール}} を使って、取得したプレーヤーの入力枠オブジェクトを @<code>{inputBox}変数に代入します。これで @<code>{inputBox}変数がプレイヤーの入力枠を指すようになりました。入力枠オブジェクト @<code>{inputBox}から プレーヤーが枠に入力した値を取得するために、@<code>{@<ruby>{value,バリュー}}メソッドが用意されていますので、これを使い、@<code>{inputBox.value} と書くとプレイヤーが枠に入力した値を得ることができます。

@<code>{@<ruby>{parse,パース}@<ruby>{Int,イント}} は、文字列としての @<code>{"0"} を解析(@<ruby>{parse,パース})し、整数値としての @<code>{0} にする関数です。一般にプログラミング言語では、文字列としての @<code>{"0"} と、整数値としての @<code>{0} とは異なります(ちょうど、漢数字の @<code>{〇}と、数値の @<code>{0} が異なるようにです)。整数値に変換した結果を、@<code>{let player = }と書いて、代入しています。

以上で、プレイヤーが入力した手を取得することができるようになりました。


//blankline
14 行目の、@<code>{let computer = 0;} は、コンピュータの手を設定しています。

0はグー、1はチョキ、2はパー という約束でした。今のところ、コンピュータは必ず「グー」を出すことにして作っていきましょう。

//blankline
それでは、プレイヤーの手とコンピュータの手が出そろったので、勝ち負けの判定を行いましょう。先ほど学んだ @<code>{if文}を使うと良いですね。
ここでは、厳密等価演算子(@<code>{===}) を使って、プレイヤーの手とコンピュータの手を比較しています。

19行目以降で、勝ち負けを判定して、それに応じたメッセージを表示させています。ブラウザを再読み込みしてやってみましょう。

ぐっと、じゃんけんゲームらしくなってきましたね。

== 乱数の利用と 入れ子になった @<code>{if文}

=== 乱数を使う
さて、コンピュータの手は「@<code>{0}」つまりいつも「グー」でしたので、プレイヤーは「@<code>{2}」つまりパーを出せば、必ず勝てます。
コンピュータも無作為に「グー」「チョキ」「バー」の手を出すようにしましょう。

そのためには、「乱数」と呼ばれる機能を使います。
JavaScriptには @<code>{Math.random()} と呼ばれる関数が用意されています。
@<code>{Math.random()} を呼ぶと、0から1未満の浮動小数点数を返します。
@<fn>{rand}
//footnote[rand][表示は一例で、「乱数」なので実行するたびに値は変わります。]


//list[][]{
Math.random()
0.9200533064823014
0.5017996980638613
0.15088182883224843
//}

わたくしたちが欲しいのは、0, 1, 2 の3つの数ですから、三倍すれば良さそうです。

//list[][]{
Math.random() * 3
2.760159919446904
1.5053990941915838
0.4526454864967453
//}

小数点以下は不要ですから、切り捨てましょう。
JavaScriptには @<code>{Math.floor()} と呼ばれる切り捨ての為の関数が用意されています。
(床関数と呼ばれます。 @<code>{Math.ceil()} は天井関数で、切り上げ、 @<code>{Math.round()} は四捨五入です。)

//list[][]{
Math.floor(Math.random() * 3)
2
1
0
//}

//list[][]{
// computer の手を 乱数で設定
let computer = Math.floor(Math.random()*3);
//}

//note[乱数関数を自作する]{
関数化して分かりやすい名前を付けると、一目でプログラムの処理を理解できる、作成したコードの再利用が図れるなどの利点があります。有益ですので、ここで作ってみましょう。

//list[][]{
// 乱数関数
// rand(0, 2)と呼ぶと 0, 1, 2 と グーチョキパー の乱数を返す
function rand(min, max){
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function rand(min, max){
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
//}

この乱数関数を使うと、無作為な手を取得するコードは、次のように書くことができます。

//list[][]{
// computer の手を 乱数で設定
let computer = rand(0, 2);
//}

すっきり、分かりやすくなりました。いろいろ関数を自作してみて下さい。
//}

=== 入れ子になった @<code>{if文}
コンピュータが無作為な手を出すようになったので、いつもパーを出して勝ちというわけにはいかなくなりました。勝敗判定も書き直す必要があります。

プレイヤーのグーチョキパー、それぞれについて、
コンピュータのグーチョキパー、全部で九通りの勝敗判定が必要です。
@<code>{if文} の中に @<code>{if文} を書くことができます。入れ子になった @<code>{if文} 、ネストした @<code>{if文} といいます。
次のように、書き直してみましょう。

//list[][janken.js][file=source/janken40.js, 1]{
//}

それでは、ブラウザを再読み込みしてみましょう。
うまく動いてくれるでしょうか。

== リファクタリング（再構成）

だいぶプログラムが長くなってきました。
より見通しの良い、分かりやすいコードとするために、ここで「@<B>{リファクタリング}」を行いましょう。

//quote{
//noindent
@<B>{リファクタリング}とは、ソフトウェア開発において、プログラムの動作や振る舞いを変えることなく、内部の設計や構造を見直し、コードを書き換えたり書き直したりすること。@<fn>{fn-it}
//}

主なリファクタリング手法として、@<B>{定数}の利用、@<B>{関数化}、@<B>{アルゴリズム改善}等が、よく用いられます。順に行っていきましょう。

=== 定数の利用

//quote{
//noindent
@<B>{定数}とは、コンピュータプログラムのソースコードなどで、ある特定の数値やデータに名前を与えたもので@<fn>{fn-it}、慣習的に定数名は全て大文字で書かれます。
//}
//footnote[fn-it][出典: IT用語辞典]

コンピュータにとって、@<code>{0}, @<code>{1}, @<code>{2} は分かりやすくて扱いやすいですが、人にとっては、@<code>{グー,} @<code>{チョキ,} @<code>{パー} のほうが分かりやすいものです。
単なる数値に名前を付けることで、理解しやすいコードを書くことができるようになります。

//list[][]{
// 先頭に「'use strict';」と書くことで、潜在的なバグを減らす。
'use strict';

// 定数宣言
// プログラム内で共通して使う定数を宣言する。
// 慣習的に定数名は全て大文字で書かれる。
const GUU   = 0; // グー
const CHOKI = 1; // チョキ
const PAA   = 2; // パー
//}

#@# const DRAW  = 0; // 相子
#@# const LOSE  = 1; // 負け
#@# const WIN   = 2; // 勝ち

と、定数を宣言します。

すると、先程の @<code>{if文} は次のように書き直せます。

//list[][]{
  // じゃんけんの勝ち負けの結果を表示する関数
  function jankenHandler(event) {
    if (player === GUU) {
      if (computer === GUU) {
        alert("相子です!");
      } else if (computer === CHOKI) {
        alert("あなたの勝ちです!");
      } else {
        alert("あなたの負けです!");
      }
    } else if (player === CHOKI) {
      if (computer === GUU) {
        alert("あなたの負けです!");
      } else if (computer === CHOKI) {
        alert("相子です!");
      } else {
        alert("あなたの勝ちです!");
      }
    } else {
      if (computer === PAA) {
        alert("あなたの勝ちです!");
      } else if (computer === CHOKI) {
        alert("あなたの負けです!");
      } else {
        alert("相子です!");
      }
    }
  }
//}

@<code>{0, 1, 2} といった数値から、 @<code>{GUU, CHOKI, PAA} という定数に変わりました。プログラムの機能は変わりませんが、単なる数値ではなく、人にとって理解しやすい意味を持つ
@<code>{GUU, CHOKI, PAA} という文字になったので、コメントも不要となるほどとても読み易いコードとなりました。

=== 関数化とアルゴリズムの改善
じゃんけんの勝敗判定部分も長く成りましたので、この部分を取り出して関数にすることにより、全体を見やすくしましょう。

//quote{
関数とは、ある一連の手続き（文の集まり）を1つの処理としてまとめる機能です。 関数を利用することで、同じ処理を毎回書くのではなく、一度定義した関数を呼び出すことで同じ処理を実行できます。また、一度しか行わない処理でも、適切な命名を行って、処理の詳細に関する部分をプログラムの呼び出し元から分離することで、コード全体の見通しが良くなる利点が得られます。
//}

また、より良いアルゴリズムを考えることで、9通りの @<code>{if文} を綺麗に書き直していきましょう。

#@# 「コンピュータプログラミングにおいて、プログラムの外部から見た動作を変えずにソースコードの内部構造を整理すること」を、「@<B>{リファクタリング}」 @<fn>{fn-r}と言います。
#@# //footnote[fn-r][出典：Wikipedia]


== じゃんけんのアルゴリズム

@<href>{https://staku.designbits.jp/check-janken/, じゃんけん勝敗判定アルゴリズムの思い出} というブログがあります。こちらを参考に、より簡潔に書けるよう、じゃんけんのアルゴリズムを考察していきましょう。

素直に @<code>{if文} を書くと、プレイヤーがグーの時、チョキの時、パーの時のそれぞれにつき、コンピュータがグーの時、チョキの時、パーの時と、九通りの勝敗判定が必要でした。

@<code>{if文} を書き連ねず、もう少し簡潔に書けるか調べるために、勝敗表にまとめます。

//table[][じゃんけんの勝敗表]{
.	グー   0	チョキ 1	パー   2
-----------------
グー   0	相子	勝ち	負け
チョキ 1	負け	相子	勝ち
パー   2	勝ち	負け	相子
//}

自分の手と相手の手が等しい時に「相子」になることが分かります。
等しいかどうかを調べるためには、@<B>{引き算してその結果が0になるか}で判定できますので、@<B>{自分の手から相手の手を引き算}してみます。
すると次の表が得られます。

//table[][じゃんけんの勝敗表 【引き算】]{
.	グー   0	チョキ 1	パー   2
-----------------
グー   0	相子   0	勝ち  -1	負け  -2
チョキ 1	負け   0	相子   0	勝ち  -1
パー   2	勝ち   2	負け   1	相子   0
//}


相子になるのは 0の時、負けになるのは -2か1の時、勝ちになるのは -1か2の時であることが判明しました。これで九通りではなく、五通りの @<code>{if文} で良いと分かりました。
//blankline
もう少し考察を加えます。勝ち負け相子の三通りの判定をする為に「本当に」五通りの @<code>{if文} が必要でしょうか。

よく見ると -2と1は3つ離れており、-1と2も3つ離れていますので、3を足してみます。すると、

  * 相子になるのは、0 か 3 の時、
  * 負けになるのは、1 か 4 の時、
  * 勝ちになるのは、2 か 5 の時となります。

なにか法則性がありそうです。もう少し3を足してみます。

  * 相子になるのは、0 か 3 か 6 か  9 の時、
  * 負けになるのは、1 か 4 か 7 か 10 の時、
  * 勝ちになるのは、2 か 5 か 8 か 11 の時となります。

法則性が見えてきたでしょうか？

 * 相子になるのは、3の倍数の時、
 * 負けになるのは、3の倍数に1を足した数の時、
 * 勝ちになるのは、3の倍数に2を足した数の時 のようです。

3の倍数であるか調べるにはどうしたら良いでしょうか？

 * 3で割ってみて、余りが0であれば、3の倍数です。

3の倍数に1を足した数であるか調べるにはどうしたら良いでしょうか？

 * 3で割ってみて、余りが1であれば、3の倍数に1を足した数です。

3の倍数に2を足した数であるか調べるにはどうしたら良いでしょうか？

 * 3で割ってみて、余りが2であれば、3の倍数に2を足した数です。

//blankline
以上の考察から、

 * 相子になるのは、3で割って余りが0の時、
 * 負けになるのは、3で割って余りが1の時、
 * 勝ちになるのは、3で割って余りが2の時であることが 分かりました。

//blankline
//sideimage[operator][25mm][sep=5mm,side=R]{
  余りを求める演算のことを「@<B>{剰余演算}」と言います。

  JavaScript では、 @<code>{@<ruby>{%,パーセント}} を使うと、剰余演算を行うことができます。
//}

#@# //tsize[latex][|c|c|]
#@# //table[][演算子の種類]{
#@# .	演算子
#@# -----------------
#@# 加算	@<code>{+}
#@# 減算	@<code>{-}
#@# 乗算	@<code>{*}
#@# 除算	@<code>{/}
#@# 剰余	@<code>{%}
#@# //}

まとめです。

 * 勝負の判定には、最初は九通りの @<code>{if文} が必要でした。
 * @<code>{自分の手 - 相手の手}とすると、五通りになりました。
 * @<code>{(自分の手 - 相手の手 + 3) % 3} として、@<code>{0, 1, 2} の三通りになりました。

それでは、相子が @<code>{0}, 負けが @<code>{1}, 勝ちが @<code>{2} と、結果を返す関数を作りましょう。

//list[][]{
// プレイヤーの手とコンピュータの手が与えられると、
// 0: 引き分け 1: 負け 2: 勝ち を返す関数
function judge(player, computer) {
  return (player - computer + 3) % 3;
}
//}

延々と @<code>{if文} を繰り返していた長い行が、とっても短く纏まりました。

それでは、ここで定義した @<code>{judge関数} を使って、プログラムを書き直してみましょう。せっかくですので「相子」「負け」「勝ち」を表す定数も使いましょう。次のようにとても分かりやすくなりました。

//list[][janken.js][file=source/janken60.js, 1]{
// じゃんけんの勝ち負けの結果を表示する関数
function jankenHandler(event) {
  // judge は、
  // プレイヤーとコンピュータの手を与えると、
  // 勝敗を返す関数です。
  // 相子なら0 , 負けなら1, 勝ちなら2が返ります。
  const result = judge(player, computer);

  if (result === DRAW) {
    // resultと0が等しかった時に、行いたい処理を記述します。
    // ここでは、「引き分け」とアラートを表示します。
    alert('引き分けです!');
  } else if (result === LOSE) {
    // else はそうでなければ、という意味です。
    // 0 と等しくなかった時に、1と等しいか、調べています。
    // 1 と等しかったら、「負け」と表示します。
    alert('あなたの負けです!');
  } else {
    // else は他のいずれにも該当しなかった際の処理を記します。
    // 引き分けでも負けでもない、つまり「勝ち」と表示します。
    alert('あなたの勝ちです!');
  }
}
//}

//clearpage

== 暦を巡る旅 - 元旦からの日数を数える

この章では、関数の利用について触れました。
@<code>{add(9, 23)}として、足し算をする簡単な関数でした。
もう少し意味のある例として、ここでは元旦からの日数を求める関数を作りたいと思います。

古来、日の巡り、月の巡りを数えることで、@<ruby>{暦,こよみ}が作られてきました。
地球は、太陽の周りを 365.2422 日かけて一周し、月は 29.5日で満ち欠けを繰り返します。
月の周期をもとにした太陰暦では、29.5日 × 12月 = 354日で一年となりますが、太陽の巡りを基にした太陽暦とは11日余りのずれを生じます。ずれをそのままにしておくと、種蒔きや収穫など、農事に支障を来しますので、おおよそ三年に一度、@<ruby>{閏,うるう}月を入れることで、季節と日月の歩みを調整する太陰太陽暦も生まれました。現在でも、季節行事などに天保歴(@<small>{明治五年に採用された新暦(グレゴリオ暦)に対し、旧暦とも呼ばれます。})は息づいています。

//sideimage[hatsuhinode][60mm][sep=5mm,side=R]{
日蝕、月蝕など空を眺めた人も多いのではないでしょうか。天文を観測し、日々の暮らしにも、春分、秋分、夏至、冬至など、@<ruby>{二十四節気,にじゅうしせっき}として根付いています。

日本では、春季皇靈祭、秋季皇靈祭として斎行され、夏至の日の朝に日が昇るストーンヘンジや、キリスト教の降誕祭は従来から行われていた冬至の祭典を由来に、復活祭は春分を基に日付を求めています。
//}


@<fn>{irasutoya0}

//footnote[irasutoya0][画像出典: 季節のイベント・動物・子供などのかわいいイラストが沢山見つかるフリー素材サイト @<href>{https://www.irasutoya.com/,いらすとや}]

=== 素朴な関数
それではHTMLファイルと、そこから呼び出されるJavaScriptファイルを作りましょう。
//list[][day.html][file=source/day.html]{
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>日付の計算</title>
  </head>
  <body>
    <h1>日付の計算</h1>
    <script src=day.js></script>
  </body>
</html>
//}

//list[][day.js][fontsize=small]{
// 元旦から m 月 d 日 までの日数を返す関数
function totalDays(m, d){
       if (m ===  1) { return d; }
  else if (m ===  2) { return 31 + d; }
  else if (m ===  3) { return 31 + 28 + d; }
  else if (m ===  4) { return 31 + 28 + 31 + d; }
  else if (m ===  5) { return 31 + 28 + 31 + 30 + d; }
  else if (m ===  6) { return 31 + 28 + 31 + 30 + 31 + d; }
  else if (m ===  7) { return 31 + 28 + 31 + 30 + 31 + 30 + d; }
  else if (m ===  8) { return 31 + 28 + 31 + 30 + 31 + 30 + 31 + d; }
  else if (m ===  9) { return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + d; }
  else if (m === 10) { return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + d; }
  else if (m === 11) { return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + d; }
  else               { return 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + d; }
}

// 九月二十三日を与える
let m =  9;
let d = 23;

// 結果表示
console.log(totalDays(m, d));

//}

実行すると、開発者ツールのコンソール画面に @<code>{266} と表示されます。
@<fn>{266}
//footnote[266][九月二十三日は、秋分の日であり、西九州新幹線の開業日でもあります。技術書典開催中の日付から印象深い日を選びました。]

本文で紹介した @<if>文の良い例になっています。そして少し観察すると前の月までの累計日数に、本日の日付を足していることが見て取れます。

=== 一行コメント @<code>{//}
JavaScript では @<code>{/* */} もコメントとして使うことができますが、「一行コメント @<code>{//}」は便利ですので良く使われます@<small>{（Atomなどのエディタでは、@<code>{Command + /} で入力できます）}。

=== 配列を使う

「リファクタリング（再構成）」を行い、より簡潔なコードにしてみましょう。
累計日数を@<ruby>{予,あらかじ}め求めておくと、すっきり書けそうです。

//list[][]{
function nissu(m, d){
       if (m ===  1) { return   0 + d; }
  else if (m ===  2) { return  31 + d; }
  else if (m ===  3) { return  59 + d; }
  // (略)
  else if (m ===  9) { return 243 + d; }
  else if (m === 10) { return 273 + d; }
  else if (m === 11) { return 304 + d; }
  else               { return 334 + d; }
}
//}

すっきり短くなりました。そしてコードを見ると、@<code>{if (m ===  9) { return 243 + d; \}} （もし九月なら、それまでの累計日数 243日に 当日までの日数を足す） と書かれています。
つまり、「月」と「累計日数」との対応表があれば、より短く書けそうです。

このような場合に役立つのが、「@<B>{配列}」と呼ばれるデータ構造です。
IT用語辞典より、意味を確認してみましょう。

//quote{
//noindent
@<B>{配列}とは、複数のデータを連続的に並べた@<B>{データ構造}。各データをその配列の@<B>{要素}といい、自然数などの@<B>{添字}（インデックス）で識別される。
//}

それでは使ってみましょう。累計日数の配列 @<code>{t} を作り、@<code>{const t = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];} と書きます。

配列の添字は @<code>{0} から始まります。ですので先頭の(〇番目の)「要素」を参照するには @<code>{t[0]} と書きます。すると @<code>{0} を取得できます。
一番目の「要素」を参照するには @<code>{t[1]} と書きます。 すると @<code>{31} を取得できます。
二番目の「要素」を参照するには @<code>{t[2]} と書きます。 すると @<code>{59} を取得できます。
十一番目の「要素」を参照するには @<code>{t[11]} と書きます。 すると @<code>{334} を取得できます。
理解を深めるために、@<code>{console.log(t[11])}として、結果を確認することもお勧めです。

//blankline
わたくしたちが使う言語（自然言語と言います）では、一番目、二番目、三番目などのように数えますが、プログラミング言語では、@<code>{0} 番目、@<code>{1} 番目、@<code>{2} 番目などのように、@<B>{0}から始まりますので、対応関係がずれます。

ですので、一月を@<B>{0}に、二月を@<B>{1}に、三月を@<B>{2}にと、対応関係をずらすことに考慮すると、次のコードを書けば良いことが分かります。 @<fn>{js-month}

//footnote[js-month][JavaScriptなど一部のプログラミング言語では、@<B>{0}月 から始まります。]


//list[][day.js][file=source/day2.js,fontsize=small]{
//}

とても短くなりました。

=== @<ruby>{閏,うるう}年を考える
月の運行をもとに季節の移り変わりとの調和を図った太陰太陽暦では、約三年に一度、閏月を入れることを紹介しました。

太陽の動きをもとにした太陽暦でも、地球の公転周期が 365.2422 日であることから、古代ローマの執政官「ユリウス・カエサル」により、一年を365日とし四年に一度閏年を設け366日とすることとしました。ユリウス歴と呼ばれ千数百年後の今日まで使われることとなりました。

四年に一度閏日を入れることで一年の日数は365.25日となり、とても正確になりました。が実際の公転周期とは差がありますので、長い年月の間に少しずつ誤差が積み重なり @<fn>{gosa}、中世には10日ほどの差が生じていました。

このままでは、キリスト教徒にとって大切な復活祭の日付を決めることができないなどの思いから、ユリウス暦の修正が検討されました。そしてローマ教皇グレゴリウス13世により、グレゴリオ暦に改暦されます。
四年に一度閏年を入れることは同じですが、400年に100回ではなく、400年に97回としました。これにより一年の日数は、365.2425日となり、精度の向上を図られました。

カトリック教会主導の改暦であったため、イタリアなどカトリック教会を奉じる諸国の導入は速かったですが、プロテスタント教国や正教会諸国、非キリスト教の国々への浸透には時を要することとなりました。

//footnote[gosa][約128年で一日になります。]

//blankline
我が国では、明治五年に「太陰曆ヲ廢シ太陽曆ヲ行フ附詔書」により、「十二月三日ヲ以テ明治六年一月一日」となりました。 @<fn>{kaireki}

急な改暦であったため、混乱も見られましたが、慶應義塾の創設者「福澤諭吉」は「改暦辧」を著し、啓蒙しました。

//quote{
  太陰暦から太陽暦に改まるに際し、政府は一片の法令を出しただけで、この大改革の理由を国民に納得せしめるの注意を怠っているのを見て、歯がゆく思い、風邪臥床中、床の上でおよそ六時間ばかりでこの書を脱稿したが、これを出版したところ夥しい発行部数を示し、著者自身も驚いた @<fn>{fn-kaireki}
//}

//image[kairekiben][][width=100%]

無学文盲の者にも分かるよう、平易な言葉遣いで書かれており、暦の仕組みを公転の図などを用いて解説しています。曜日や月の名、時計の図の紹介もあります。ぜひ、ご一読下さいませ。

//footnote[fn-kaireki][@<href>{https://dcollections.lib.keio.ac.jp/en/fukuzawa/a18/67,改暦辧}]



//footnote[kaireki][https://dl.ndl.go.jp/info:ndljp/pid/787952/172,国立国会図書館 太陰暦ヲ廃シ太陽暦ヲ頒行ス]

//sideimage[uruudoshi_ss][60mm][sep=5mm,side=R]{
  明治三十一年に、右のように閏年に関する規定が補足されています。 @<fn>{uruudoshi}

//blankline
  令和四年は、神武天皇即位紀元（皇紀）二千六百八十二年ですので、「四ヲ以テ整除シ得ヘキ年」ではありませんので、平年となります。

//blankline
  この勅令が公布された翌々年に当たる明治三十三年は、神武天皇即位紀元（皇紀）二千五百六十年です。「四ヲ以テ整除シ得ヘキ年ヲ閏年トス」（４で割り切れる年は閏年）とありますので閏年になりますが、但し書きが書かれていますので、見てみましょう。

  但し書きには、「紀元年数ヨリ六百六十ヲ減ジテ百ヲ以テ整除シ得ヘキモノノ中更ニ四ヲ以テ其ノ商ヲ整除シ得サル年ハ平年トス」と書かれています。二千五百六十より六百六十を減らすと千九百になります。千九百は「百を以テ整除シ得ヘキモノ」（１９００は１００で割り切れます）ではありますが、「更ニ四ヲ以テ其ノ商ヲ整除シ得サル年」では無い（１９は４で割り切れない）ので「平年」となります。

//blankline
  平成十二年、神武天皇即位紀元（皇紀）二千六百六十年も見てみましょう。「四ヲ以テ整除シ得ヘキ年ヲ閏年トス」とありますので閏年になりますが、但し書きも見てみましょう。

  二千六百六十より六百六十を減らすと二千になります。二千は「百を以テ整除シ得ヘキモノ」です。「更ニ四ヲ以テ其ノ商ヲ整除シ得サル年ハ平年トス」と書かれていますが、２０は４で割り切れるので、但し書きの規定に関わらず「閏年」となります。
//}
//footnote[uruudoshi][@<href>{https://www.digital.archives.go.jp/file/154407.html,国立公文書館デジタルアーカイブ 閏年ニ関スル件}]

//vspace[latex][2mm]
//blankline
世界一長い歴史を誇る我が国では、神武天皇即位紀元（皇紀）が、仏教国のタイではお釈迦様の入滅を元年とする仏滅紀元が、イスラム諸国においては預言者ムハンマドの聖遷から始まるヒジュラ暦が、ユダヤ教徒においては神が世界を創世した日を紀元とする暦が使われています。インド暦、マヤ歴など、キリスト生誕を始まりとするグレゴリオ暦の他にも様々な暦があります。 @<fn>{hosi}

国立天文台の @<href>{https://www.nao.ac.jp/faq/a0307.html, 1月1日はどうやって決まったの} や、@<href>{https://eco.mtk.nao.ac.jp/koyomi/topics/html/topics2014.html, 旧暦2033年問題について} にも楽しい話題が掲載されておりますので、ご一読下さいませ。

//footnote[hosi][@<href>{http://hosi.org,世界各国の暦}]

=== 閏年を判定するプログラム

それでは、ここまでの話を踏まえて、閏年を判定するプログラムを作りましょう。

//list[][]{
// 閏年を判定する関数
function leapYear(kouki) {
  // 四ヲ以テ整除シ得ヘキ年ヲ閏年トス
  if (kouki % 4 === 0) {
    // 紀元年数ヨリ六百六十ヲ減ジテ百ヲ以テ整除シ得ヘキモノノ中更
    if ((kouki-660)%100 === 0) {
      // 更ニ四ヲ以テ其ノ商ヲ整除シ得サル年ハ平年トス
      if ( ((kouki-660)/100) % 4 !== 0) {
        return 0; // 平年
      } else {
        return 1; // 閏年
      }
    }
    return 1; // 閏年
  } else {
    // 四ヲ以テ整除シ得サル年
    return 0; // 平年
  }
}

// 結果表示
let kouki = 2682; // 令和四年
console.log(leapYear(kouki));
//}

勅令通りに作成しましたら、少し長いコードとなりました。
もう少し、簡潔に書けないものでしょうか。

勅令を良く読むと@<br>{}
「紀元年数ヨリ六百六十ヲ減ジ」４００で割り切れる年 @<br>{}
又は @<br>{}
「紀元年数ヨリ六百六十ヲ減ジ」４で割り切れ、且つ１００で割り切れない年 @<br>{}
が閏年であることが分かります。

@<code>{if}文の中では、「又は」は @<code>{||} を使って、「且つ」は @<code>{&&} を使って書くことができます。
「紀元年数ヨリ六百六十ヲ減ジ」た年は、ユリウス歴、グレゴリオ暦ですから、次のように書けます。

//list[][]{
// 閏年を判定する関数
function leapYear(kouki) {
  // 紀元年数ヨリ六百六十ヲ減ジ
  let gregorian = kouki - 660;

  // 四ヲ以テ整除シ得ヘキ年ヲ閏年トス
  if ((gregorian % 400 === 0) ||
      (gregorian % 4 === 0 && gregorian % 100 !== 0)) {
    return 1; // 閏年
  } else {
    return 0; // 平年
  }
}

// 結果表示
let kouki = 2682; // 令和四年
console.log(leapYear(kouki));
//}

閏年を考慮した、元旦からの日数を数えるプログラムは次のようになります。

//list[][day3.js][file=source/day3.js]{
// 元旦から m 月 d 日 までの日数を返す関数
function totalDays(m, d){
  // その月までの日数の累計を納めた配列
  const t = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  // 結果を返す
  return t[m-1] + d;
}

// 閏年を判定する関数
function leapYear(kouki) {
  // 紀元年数ヨリ六百六十ヲ減ジ
  gregorian = kouki - 660;

  // 四ヲ以テ整除シ得ヘキ年ヲ閏年トス
  if ((gregorian % 400 === 0) ||
      (gregorian % 4 === 0 && gregorian % 100 !== 0)) {
    return 1; // 閏年
  } else {
    return 0; // 平年
  }
}

// 令和四年九月二十三日を与える
let k = 2682;
let m =    9;
let d =   23;

// 結果表示
if (m <= 2) {
  console.log(totalDays(m, d));
} else {
  console.log(totalDays(m, d) + leapYear(k));
}
//}

=== ユリウス@<ruby>{通日,つうじつ}
天文学がお好きな方でしたら、ユリウス@<ruby>{通日,つうじつ} をご存じかもしれません。ウィキペディアより引用しつつご紹介いたします。
@<fn>{julian_day}
//footnote[julian_day][@<href>{https://ja.wikipedia.org/wiki/ユリウス通日,ユリウス通日}]

フランスのカルヴァン派の宗教指導者であったスカリゲルによってユリウス暦、グレゴリオ暦双方での日付の換算や日数計算の便のために考案されました。

スカリゲルが基準にした紀元前4713年は、以下の3つの周期の第1年目が重なる年です。

  * 太陽章（英語版）（28年） - 日付と七曜が揃う周期
  * 太陰章（メトン周期）（19年） - 月相（月の満ち欠け）と日付が揃う周期
  * インディクティオ（15年） - ローマ帝国での徴税額の査定更正周期

以上の3つの周期が揃うには7980年 (＝28×19×15)を要します。

その後、天文学者ジョン・ハーシェルが1849年の著書 Outlines of Astronomy で日数や時間の計算にユリウス通日を利用する方法を考案、世界中の天文学者が日数計算にユリウス通日を用いるようになった。 またユリウス通日では桁が多すぎて不便な場合に、修正ユリウス日（Modified Julian Date：MJD）が使われます。これはユリウス通日から 2,400,000.5 を差し引いたものです。

=== グレゴリオ暦から修正ユリウス日への換算
グレゴリオ暦 y 年 m 月 d 日午前0時の修正ユリウス日は次式で表されます。

ただし1月、2月は前年の13月、14月として計算します。

//image[mjd][][width=80%]
//vspace[latex][5mm]

//sideimage[floor][20mm][sep=5mm]{
この記号は、ガウス記号や床関数と呼ばれ、@<code>{x} を越えない最大の整数を返します（「床」に着くから「床関数」で、逆は「天井関数」です）。例えば、@<code>{y} が @<code>{1} の時、@<code>{365.25} となりますが、これを越えない最大の整数 @<code>{365} を返します。

JavaScriptでは、床関数は @<code>{Math.floor(365.25 * y)} として計算できます
（ちなみに、天井関数は @<code>{Math.ceil(x)} です）。
//}

=== 七曜日の求め方

//sideimage[mjdyoubi][60mm][sep=5mm,side=R]{

該当日の修正ユリウス日を7で割り、余りを求め、右記の換算表により曜日を求めることができます。これは本質的には「ツェラーの公式」と同じです。

//}

//blankline
暦を巡る計算に関して、いろいろご紹介いたしましたが、お楽しみいただけましたでしょうか。
様々な文献、サイトもございますので、ご興味を持っていただければ幸いです。

//image[gengou_calender_reiwa][][width=60%]
