= アルゴリズム とは
//abstract{
  アルゴリズムとは、「計算や作業を遂行するための手順」のことです。良いプログラムを作る上で、アルゴリズムの理解は欠かせません。
  有名なアルゴリズムの紹介とともに、その表現に良く用いられる「流れ図」や「効率性」の考察も行います。
//}

== アルゴリズムとは
語源は、九世紀前半を生きたアラビアの数学者アル・フワーリズミーに因みます。日本語では「算法」と訳されます。

@<href>{https://e-words.jp/w/アルゴリズム.html, IT用語辞典} には、次のように説明されています。

//quote{
アルゴリズムとは、「ある特定の問題を解く手順を、単純な計算や操作の組み合わせとして明確に定義したもの」。数学の解法や計算手順なども含まれるが、ITの分野ではコンピュータにプログラムの形で与えて実行させることができるよう定式化された、処理手順の集合のことを指すことが多い。

曖昧さのない単純で明確な手順の組み合わせとして記述された一連の手続きで、必ず有限回の操作で終了し、解を求めるか、解が得られないことが示される。コンピュータで実行する場合は、基礎的な演算、値の比較、条件分岐、手順の繰り返しなどを指示する命令を組み合わせたプログラムとして実装される。

数値などの列を大きい順または小さい順に並べ替える「整列アルゴリズム」、たくさんのデータの中から目的のものを探し出す「探索アルゴリズム」、データが表す情報を損なわずにより短いデータに変換する「圧縮アルゴリズム」といった基本的なものから、画像の中に含まれる人間の顔を検出する、といった複雑なものまで様々な種類のアルゴリズムがある。

同じ問題を解くアルゴリズムが複数存在することもあり、必要な計算回数や記憶領域の大きさ、手順のシンプルさ、解の精度などがそれぞれに異なり、目的に応じて使い分けられる。例えば、ある同じ問題に対して、原理が単純で簡単にプログラムを記述できるが性能は低いアルゴリズム、計算手順が少なく高速に実行できるが膨大な記憶領域を必要とするアルゴリズム、厳密な解を求めるものより何桁も高速に近似解を求めることができるアルゴリズムなどがある。
//}

巻末の参考文献「アルゴリズム図鑑」には、並び替えや探索など基本的なものから、暗号化やデータ圧縮まで様々なアルゴリズムが分かりやすく図解されていますので、是非、ご一読下さい。


=== ユークリッドの互除法
//sideimage[Euclidean][30mm][sep=5mm]{
紀元前300年頃に記されたユークリッドの『原論』に記されている世界最古のアルゴリズムである。
2つの自然数(1071と1029)の最大公約数を求める例を挙げる。1071 を 1029 で割った余りは 42。1029 を 42 で割った余りは 21。42 を 21 で割った余りは 0。よって、最大公約数は21である。として簡単に求めることが出来る。
それぞれの自然数を素因数分解しても最大公約数を求めることができるが、ユークリッドの互除法を用いると格段に速く計算可能である。

@<small>{(「ラメの定理」により、割って余りを取る操作を、最悪でも小さい十進数の桁数の約5倍繰り返せば、最大公約数に達する。)}
//}

=== エラトステネスの @<ruby>{篩,ふるい}
//sideimage[Eratosthenes][50mm][sep=5mm]{
古代ギリシアの科学者エラトステネスが考案した、指定された整数以下の全ての素数を発見するための単純なアルゴリズム。100までの素数を見つける場合、図のように2から100までの数を篩に入れておく。次に篩の中で最小の数2は素数の為、その倍数を篩い落とす、残った数の中で最小の数3は素数の為、その倍数を篩い落とす。これを順に繰り返していき、11(√100より大きな最初の素数)に達した時点で、篩に残っていた全ての数は素数である。
また、地球の大きさを最初に測定したことでも知られている。
//}

=== ハノイの塔
//sideimage[Hanoi][50mm][sep=5mm]{
パズルの一種。三本の杭と、大きさの異なる複数の円盤があり、左端の杭に小さいものが上になるように順に積み重ねられている。円盤を一回に一枚ずつどれかの杭に移動させることができるが、小さな円盤の上に大きな円盤を乗せることはできない。右端の杭に全ての円盤を移動させよ。
//}

=== ナップサック問題
//sideimage[knapsack][50mm][sep=5mm]{
「袋には15kgまで入れられる。重量や価値の異なる様々な品があるが、袋の価値を最大化するためには、どの品を詰めたら良いか？」という問題で、計算複雑性理論に於て、NP困難と呼ばれる問題のクラスに属する。動的計画法を用いた擬多項式時間アルゴリズムにより、実用的にはほぼ最適な解が得られる。
//}
//vspace[latex][2mm]
貪慾法と呼ばれるアルゴリズムでの解答例を示す。「貪慾」という名前の通り、各荷物の評価値(=価格÷重量)を算出し、評価値の高いものからナップサックに入れていくのが骨子である。
①の品は価値が2ドル重量が2kgであるから評価値は2/2=1、②の品は・・・と順に算出していくと、①〜④の品を選んだときに、価値が15ドル重量が8kgであると(最適解ではないにしろ一応の)解が得られる。


=== 巡回セールスマン問題 @<fn>{shutten}
//sideimage[salesman][50mm][sep=5mm]{
ある地域の営業担当のセールスマンが、その地域に住んでいる顧客全員の家を巡回して訪ねることになったとする。巡回の順番によって移動距離が大きく変わるので、移動距離が少なくなるような巡回の方法を求めたい。
//}


//footnote[shutten][巡回セールスマン問題はimidasより、他はウィキペディアより引用・改変]


== データ構造

プログラミング言語 Pascal の開発者 ニクラウス・ヴィルト氏による名言、@<B>{「プログラミング」＝「データ構造」＋「アルゴリズム」} は、広く知られています。アルゴリズムに密接な関係があるデータ構造についても、@<href>{https://e-words.jp/w/データ構造.html, IT用語辞典} より、ご紹介いたします。

=== データ構造とは
データ構造とは、データの集まりをコンピュータプログラムで扱いやすいように、一定の形式で格納したもの。特定の問題を解く手順（アルゴリズム）には、それぞれに適したデータ構造がある。

複数のデータの配置や関係性、データの参照や出し入れなどの操作のルールを定義したもので、様々な種類がある。それぞれに特徴や適した処理があるため、同じ処理の記述でも、目的に対して適切なデータ構造を選択できるかどうかでプログラムの複雑さや処理性能に大きな差がつくことがある。

=== データ構造の種類
最も基本的なデータ構造には、要素を一列に並べた「配列」（array）、要素を格納した順に取り出すことができる「キュー」（queue）、格納したのとは逆順に取り出すことができる「スタック」（stack）などがある。

格納された要素への参照データを含むデータ構造もあり、任意の標識と要素を一対一に関連付けて格納する「連想配列」（辞書、ハッシュ、マップとも呼ばれる）、要素が前後の要素への参照を持つ「連結リスト」（linked list）、要素が任意個の他の要素への参照を持つ「グラフ」（graph）、一つの頂点から樹状に枝分かれしたグラフである「木構造」（ツリー構造）などがある。

=== 言語上の扱い
プログラミング言語では、基本的なデータ構造のいくつかが言語仕様や標準ライブラリなどにあらかじめ組み込まれて提供されていることが多い。用意されていない場合でも、既存のデータ構造や複合データ型、クラスなどの仕様を利用して開発者がデータ構造の定義や挙動の実装を行うことがある。

実際のプログラム上では基本的なデータ構造を単体で用いることも多いが、あるデータ構造の要素として別のデータ構造を格納するなど、アルゴリズムに合わせて組み合わせて用いる場合もある。

=== 各データ構造のイメージ

#@# == アルゴリズムとデータ構造
#@# TODO: 書く必要ある？　参考文献みてねでいいかも
#@# プログラム = アルゴリズム + データ構造 アルゴリズム
#@#
#@# === アルゴリズム
#@# 数学、コンピューティング、言語学、あるいは関連する分 野において、問題を解くための手順を定式化した形で表現したものを言う。「算法」と訳されることもある。
#@# 「問題」はその「解」を持っているが、アルゴリズムは正しくその解を得るための具体的手順 および根拠を与える。さらに多くの場合において効率性が重要となる。
#@#
#@# === データ構造
#@# データ構造(データこうぞう、英: data structure)は、計算機科学において、データの集まりを コンピュータの中で効果的に扱うため、一定の形式に系統立てて格納するときの形式のことで ある。
#@# ソフトウェア開発において、データ構造についてどのような設計を行うかは、プログラム(ア
#@# ルゴリズム)の効率に大きく影響する。そのため、さまざまなデータ構造が考え出されている。
#@#
#@# 基本的なデータ構造
#@#  * 配列
#@#  * スタック
#@#  * キュー
#@#  * 連想配列
#@#  * ハッシュテーブル / ルックアップテーブル 線形リスト
#@#  * 木構造
#@#  * グラフ


データ構造のイメージをご紹介します。
図の出典は巻末の参考文献「アルゴリズム図鑑」(グラフについてはウィキペディア)です。

//blankline
//sideimage[array][60mm][sep=5mm,side=R]{
@<B>{配列}@<br>{}
もっとも基本的なデータ構造です。いくつかの要素をまとめたもので、個々の要素にアクセスする際には、@<code>{a[0]}、@<code>{a[1]}、@<code>{a[2]} と添字と呼ばれる番号を用いてアクセスできます。どの要素にも添字ですぐにアクセスできる長所の反面、途中への要素の追加や削除は苦手です。

とある学級で出席番号で呼ぶような雰囲気です。
//}

//blankline

//sideimage[list][60mm][sep=5mm,side=R]{
@<B>{リスト}@<br>{}
連結リストとも呼ばれます。個々の要素が、次の要素への参照を保持している点が特徴です。リストの途中に新しい要素「緑」を追加したい際には、「青」の参照先を「緑」に変更するのみで良く、要素の追加や削除が容易であるとの利点があります。反面、どの要素があるかは、先頭から順に辿ることとなるため、時間がかかることとなります。

とある学級で一列に生徒が並んでいるとき、生徒は自分の名前とその次の生徒の名前を知っているような状態です。
//}


//blankline
//sideimage[stack][60mm][sep=5mm,side=R]{
@<B>{スタック(積ん読)}@<br>{}
いつか読みたいと思っている本を机の上に積み上げておく事はないでしょうか。「@<ruby>{積ん読,つんどく}」と呼ばれる行為です。スタックもこれと同様で、後からデータが来るたびに上に積み上げ、データを取り出す際も上にあるもの(後から来たもの)から順に取り出す構造です。後入れ先出し、LIFO です。
//}

//sideimage[queue][60mm][sep=5mm,side=R]{
@<B>{キュー(待ち行列)}@<br>{}
買い物などの待ち行列のイメージで捉えられるデータ構造です。先に来たデータを先に処理していきます。先入れ先出し、FIFO です。

//}

//blankline
//sideimage[hash][60mm][sep=5mm,side=R]{
@<B>{連想配列}@<br>{}
辞書を引くと「Joe」の項目の説明文には「M」と書かれているように見えるところから「辞書」、
「Joe」というデータを適宜「切り刻んで(ハッシュ)」「M」にするところから「ハッシュ」、
「Joe」を「M」に「対応付ける（マッピングする）」ところから「マップ」とも呼ばれるデータ構造です。
//}


//blankline
//sideimage[tree][60mm][sep=5mm,side=R]{
@<B>{@<ruby>{木構造,きこうぞう}}@<br>{}
図の上下をひっくり返すと、丁度、木が空に伸びて行くように見えるので、「@<ruby>{木, き}」、「@<ruby>{木構造, きこうぞう}」と呼ばれるデータ構造です。

「木」に@<ruby>{準,なぞら}えて、根元にある「15」は「根」、「9」や「23」などは「節」、先端の「8」や「12」などは「葉」と呼ばれます。また「3」から「8」などのつながりは「枝」と呼ばれます。「根」の「15」から「葉」の「8」までは、三本の「枝」があるので、木の「高さ」（または深さ）は「3」です。

図は、「@<ruby>{二分木,にぶんぎ}」と呼ばれる「木」で、データの探索や並び替えなどに良く用いられます。

//}

//sideimage[graph][60mm][sep=5mm,side=R]{
@<B>{グラフ}@<br>{}
「木」と似ていますが、「枝」が繋がって「閉路」を為す点が異なります。

「1」番の駅から「6」番の駅に行くには、どの経路を辿ったら良いかなど、様々に利用されています。
//}

== アルゴリズムと効率性

//sideimage[sum][40mm][sep=5mm]{

ここでは、アルゴリズムの例として、1から10までの合計を求めます。
左図は「流れ図(フローチャート)」と呼ばれ、手順を示す際に良く使われます。 @<br>{}

 - 1. 「n」という名前の箱を用意し、１を入れます。
 - 2. 10 より n が大きいか、条件判断します。
 - 3. NO なら、
    「s」という名前の箱に、s + n を計算した答えを入れて、
    「n」という名前の箱に、n + 1 を計算した答えを入れます。
    そして、2 に戻ります。
 - 4. YES なら、「終了」です。
    １から10までの合計が、「s」という名前の箱に入っています。 @<br>{}

計算するための手順が「きちん」と書かれているので、確実に答えを求めることができます。

それではこのアルゴリズムの効率をみていきましょう。
1から10までの合計を求める時の計算量(足し算の回数)は10回になります。
1から100までの合計を求める時の計算量(足し算の回数)は100回になります。
1から1000までの合計を求める時の計算量(足し算の回数)は1000回になります。

このように、nに比例して計算量が増えることを、 @<code>{O(n)} と書き、 @<code>{オーダーn} と読みます。
//}
//vspace[latex][2mm]
より良いアルゴリズムとして、次のように求めることも出来ます。

//list[][]{
  (1 + n) * (n / 2) → s
//}

計算量は @<code>{O(1)}と、@<code>{n} によらず、一定の時間で計算することができ、最高に効率的です。

解きたい課題に対して複数のアルゴリズムがあります。計算速度や実装の容易さなどを思案し、良いプログラムを書いていきましょう。


//clearpage

== 素数を求めるプログラム



=== 手計算で行う
アルゴリズムのご紹介で、素数を求める為のアルゴリズム「エラトステネスの@<ruby>{篩,ふるい}」をご紹介いたしました。

少しアルゴリズムは異なりますが、素数を求めて見ましょう。
素数は、1と自分自身以外では割り切れない数のことです。
最初の偶数2は素数ですが、次の偶数4以降は2で割り切れますので、奇数を対象に調べて行くことにしましょう。

例えば、21が素数かどうかは、21以下の素数(3, 5, 7, 11, 13, 17, 19) で割り切れるかどうか、計算することによって調べることが出来ます。

//tip{
21 ÷  3 =  7 余り  0 なので 割り切れる

なので、21は素数ではない。
//}

あるいは、23が素数かどうかは、23以下の素数(3, 5, 7, 11, 13, 17, 19) で割り切れるかどうか、計算することによって調べることが出来ます。

//tip{
23 ÷  3 =  7 余り  2 なので 割り切れない

23 ÷  5 =  4 余り  3 なので 割り切れない

23 ÷  7 =  3 余り  2 なので 割り切れない

23 ÷ 11 =  2 余り  1 なので 割り切れない

23 ÷ 13 =  1 余り 10 なので 割り切れない

23 ÷ 17 =  1 余り  6 なので 割り切れない

23 ÷ 19 =  1 余り  4 なので 割り切れない

なので、23は素数である。

新しい素数が見つかったので、素数達に追加する。
//}

25が素数かどうかは、25以下の素数(3, 5, 7, 11, 13, 17, 19, 23) で割り切れるかどうか、計算することによって調べることが出来ます。

//tip{
25 ÷  3 =  8 余り  1 なので 割り切れない

25 ÷  5 =  5 余り  0 なので 割り切れる

なので、25は素数ではない。
//}

と順に調べていくことで、100までの素数は、
@<code>{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} と求められます。

この手順を順に繰り返せば、1,000までの素数、10,000までの素数とどんどん素数を見つけて行くことができます。


=== プログラムを書いて見る
手作業で行うには少し労力がかかりますので、プログラムを書いて見ましょう。
様々なプログラミング言語がありますが、ここでは優れた書き味で人気の プログラミング言語 @<ruby>{Ruby,ルビー} で、書いてみましょう。

次のようなコードになります。

//list[][素数を求めるRubyのプログラム][1]{
# 変数primes に 100までの素数達の配列[3, 5, 7, ... , 97] を代入する
primes = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

# 101から1000まで2つずつ順に数nを増やす
101.step(1000, 2) do |n|
  # flag(旗)を用意する。最初はtrue(眞)にして置く。
  flag = true

  # 素数達の配列primes[3, 5, 7, ... , 97] から順に一つずつ取り出して、
  # prime に セットする。
  # prime は最初は 3 だが、5 になり、 7 になりと、
  # 最後の 97 になるまで、do ~ end 内の処理を繰り返す。
  primes.each do |prime|
    # もし n を prime で割った余りが 0 に等しいならば
    # ( % は 余りを求める演算です)
    if n % prime == 0
      # flag を 倒す。
      # false(偽)をセットする。
      flag = false
      # break(中断)
      break
    end
  end

  # もし flag が 眞 なら 素数なので、
  # (途中で、割り切れているなら、flag が 偽 になっているはずなので)
  if flag == true
    # 素数達の配列に、素数として新しく見つかった数nをpush(押し込む)する。
    primes.push(n)
  end
end

# 最後に 素数達を表示する
p primes
//}

@<code>{Ruby} では、 @<code>{#} の後ろに、コメント（説明書き）を書くことが出来ます。豊富に説明書きを入れておきましたので、英語に近いものとして自然に読みといて行けるかと思いますが、いかがでしょうか。

お手元のコンピュータに @<code>{Ruby} をインストールして、動かすことも出来ますし、よりお手軽に、@<href>{https://paiza.io/projects/UqC6dww3tK5wEl94SKYPeg,paiza.io}より、動作を確かめることも出来ます。

//image[prime][][width=100%]

@<code>{[3, 5, 7, ... , 977, 983, 991, 997]} と求めた素数達も画面下に表示されています。
手計算で1000までの素数を求めるのは少し手間ですし、間違いも起きやすいものですが、わずか14行のプログラムで求めることが出来ました。

=== 素数定理 - いくつの素数が存在するか推測する

最初の @<code>{101.step(1000, 2) do |n|} と書かれているところで、@<code>{1000}を@<code>{10000}に変えると、@<code>{10000} までの素数も求めることができますので、やって見ましょう。すぐに結果が出るかと思います。

もう一桁増やして@<code>{100000} までの素数はいかがでしょうか。@<code>{Ruby} では大きな数を入力するときに、@<code>{10_0000} と、@<code>{_(アンダースコア・下線)}を使って見やすくすることもできます。お手元のコンピュータで動かしている方はだいぶ待ってから結果が表示されたことと思いますし、また paiza.io で動かしている方は結果が表示されなかったかと思います。

数が大きくなると、素数の数も増えるだろうと想像はつきますが、一体どれくらいの割合で素数は現れるのでしょうか。素数定理 @<fn>{gausu}という、素数の出現率に関する定理があります。 @<m>$10^n$ までの素数の数を @<m>$f(10^n)$ とすると、(若干の誤差はありますが)次の公式によって求めることができます。

//footnote[gausu][後の大数学者ガウス少年は15歳の時に発見したそうです。最初の証明は死後40年を経て与えられました。]

//image[prime_number_theorem][][width=50%]

@<m>$n=3$ として、計算してみます。

//texequation{
  f(10^3) = \frac{10^3}{3} \times 0.4343 = 144.6219
//}

となりました。1000までの実際の素数の数は167個ですから、144.6219個という推測結果は、少し誤差はありますが、おおよその数を求めることが出来ています。
素数の分布はとても興味深い話題で、@<href>{https://www.shokabo.co.jp/column-math/column-math0004.html,素数定理を紐解く} により詳しく説明がございます。読みやすい文章ですので、是非ごらんになってください。


=== より効率的なアルゴリズムに改良する

そこで少しプログラムの素数を求めるアルゴリズム（計算手法）を見直して見ましょう。

//tip{
@<B>{1000までの素数}@<br>{}
2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997
//}

最後に発見した997が素数かどうかを調べる手順を振り返って見ましょう。

//tip{
997 ÷  3 =  332 余り  1 なので 割り切れない

997 ÷  5 =  249 余り  2 なので 割り切れない

997 ÷  7 =  142 余り  3 なので 割り切れない

(略)

997 ÷ 977 =   1 余り 20 なので 割り切れない

997 ÷ 983 =   1 余り 14 なので 割り切れない

997 ÷ 991 =   1 余り  6 なので 割り切れない
//}

と、166回の余りを求める演算（剰余演算）を行いましたが、もう少し演算回数を減らすことは出来ないものでしょうか。

最初の3や5、7で割り切れるか確認するのは仕方ないとしても、最後の983や991で割り切れるか調べるのは無駄な気がします。

例えば @<m>$969 = 57 \times 17$ ですので、969が素数か合成数かを調べる為には、57で割る以前に17で割ることで検出されているはずです。

//tip{
969 ÷ 17 =   57 余り  0 なので 割り切れるので合成数

969 ÷ 57 =   17 余り  0 なので 割り切れるので合成数
//}

つまり、逆に言えば、17以下の素数で割り切れるか否かを調べることで、@<m>$17^2=289$以下の素数を、57以下の素数で割り切れるか否かを調べることで、@<m>$57^2=3249$以下の素数を調べることが出来ます。

@<m>$37^2=1369$なので、1000以下の素数を求める為には、37以下の素数で割り切れるか調べれば良いので、166回必要だった剰余演算の回数を11回まで、劇的に減らすことが出来ます。

//list[][改良版のプログラム][1]{
# 変数primes に 100までの素数達の配列[3, 5, 7, ... , 97] を代入する
primes = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

# 101から1000まで2つずつ順に数nを増やす
101.step(1000, 2) do |n|
  # flag(旗)を用意する。最初はtrue(眞)にして置く。
  flag = true

  # 素数達の配列primes[3, 5, 7, ... , 97] から順に一つずつ取り出して、
  # prime に セットする。
  # prime は最初は 3 だが、5 になり、 7 になりと、
  # 最後の 97 になるまで、do ~ end 内の処理を繰り返す。
  primes.each do |prime|
    # divmod は、割り算の商と余りを同時に求める演算(メソッド)です。
    # n を prime で割った商をqに、余りをrに代入します。
    q, r = n.divmod(prime)
    # もし 余り r が 0 に等しいならば
    if r == 0
      # flag を 倒す。
      # false(偽)をセットする。
      flag = false
      # break(中断)
      break
    end

    # もし q < prime となっており、
    # その時にまだ flag が眞のままならば
    # 971 ÷ 37 =  26 余り 9 なので 割り切れず、flag は 眞のままである。
    # つまり素数なので、
    if q < prime && flag == true
      # 素数達の配列に、素数として新しく見つかった数nをpush(押し込む)する。
      primes.push(n)
      # 素数として発見できたので、
      # もう他の素数で割って検証する必要もない。
      # なので、break(中断)して、
      # 次の素数候補の検証に移ることとする。
      break
    end
  end
end

# 最後に 素数達を表示する
p primes
//}

お手元のコンピュータで実行しても良いですし、ブラウザから @<href>{https://paiza.io/projects/jhzHstHwnmnx3vNgAa-_IQ,paiza.io} で確認することも出来ます。

効率的に素数判定できるようになったので、@<code>{1_0000, 10_0000}と増やしてみましょう。
速く結果が返ってくるようになりました。

=== 実行速度の表

各人、さまざまな計算機環境かとは思いますが、ご参考までに筆者の手元で計算した結果を掲載いたします。


//tsize[latex][|r|r|r|r|]
//table[][素数を求める実行時間][csv=on,hline=off]{
いくつまでの@<br>{}素数を求めるか, 初期版の処理時間@<br>{}単位:秒, 改良版の処理時間@<br>{}単位:秒, 性能比@<br>{}単位:倍
====================================================================
       1000,   0.0007889999978,   0.0007849999964,  1.0051
     1_0000,   0.0311270000092,   0.0057969999907,  5.3695
    10_0000,   1.7517559999978,   0.0777740000048, 22.5237
   100_0000, 112.8859519999969,   1.2790039999963, 88.2608
  1000_0000, 　(計測せず)　　   ,  25.1513839999970,　
1_0000_0000, 　(計測せず)　　   , 546.1275220000098,　
//}

アルゴリズムを工夫することで、多くの素数を知ることが出来るようになりました。

127や8191は素数であり、これらの積 1040257 も容易に計算することができます。逆に素因数分解することは順に素数で割って見るより他無く、大変に時間がかかります。この性質を利用したのがRSA暗号で、公開鍵暗号方式として、安全にインターネット通信が行われる基盤として、広く使われている技術です。

//blankline
より良いアルゴリズムを求めて今日でも様々な研究開発が行われています。ご自身の解決したい課題に適切なアルゴリズムを工夫されるのも良いですし、多くの先人達が優れた技法を考案されておりますので、その叡智を拝借するのも良いでしょう。また、もしかすると、ご自身の研究開発されたアルゴリズムが、未来の人類への貢献になるやもしれません。

アルゴリズムの世界を楽しみ、探求する最初の一歩になれば幸いです。

//clearpage


===[column] カール・フリードリヒ・ガウス
後に数学王と呼ばれたガウス少年の逸話をウィキペディアより紹介します。

//vspace[latex][2mm]
//sideimage[Gauss][40mm][sep=5mm]{

ガウスが7歳の時、数学の授業で教師が「1から100までの数字すべてを足せ」という問題を出した。教師は生徒たちが問題を解くには相当な時間がかかるだろうと考えていたが、ガウスはわずか数秒で「5050」という解答を出し、教師を驚かせた。

1から100までの数字を足すと、1＋100=101、2+99=101、…、50+51=101で、101の集まりが50個できるため、101×50=5050になるとガウスは計算しました。

//blankline
19歳の時にコンパスと定規のみで正十七角形を作図できることを証明したガウスは、自身の墓碑に正十七角形を刻むよう遺言した逸話も知られています。 @<fn>{17}
//}

//vspace[latex][2mm]
//sideimage[heptadecagon][30mm][sep=5mm,side=R]{
その後もガウスは、素数定理や最小自乗法など赫々たる業績を挙げ、数学界に巨大な足跡を記しました。
//}
//flushright{
@<B>{正十七角形　　}
//}

1777年 - ドイツ、ブラウンシュヴァイクに生まれる

1792年 - 素数定理の成立を予想

1795年 - 最小二乗法発見

1796年 - 平方剰余の相互法則の証明。 @<br>{}
　　　 　　コンパスと定規のみで正十七角形を作図できることを証明

1799年 - 代数学の基本定理の証明

1801年 - 『整数論の研究』出版　複素数表記、現代整数の表記導入

1801年 - 円周等分多項式の研究

1807年 - ゲッティンゲンの天文台長になり、以後40年同職につく

1809年 - 『天体運行論』出版　最小二乗法を用いたデータ補正、正規分布

1811年 - 複素積分、ガウス平面（複素数平面）ベッセルへの手紙

1827年 - 『曲面の研究』出版、微分幾何学を創始

1855年 - ゲッティンゲンで死去

//footnote[17][@<href>{http://hooktail.sub.jp/algebra/ConstructablePolygons/, 作図可能な正多角形}]


===[/column]
